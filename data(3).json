{"practiceType":"Secure Development","selectedClient":"Standard","associated":[],"metadata":{"clientName":"Standard","clientAddress":"","appName":"","appDescription":"","testType":"Penetration Test - Essential","startDate":"","endDate":"","scope":"","scopeType":"","outOfScope":"","outOfScopeType":"","controlList":"","consultantName":"","consultantTitle":"","consultantNumber":"","consultantEmail":"","oversightName":"","oversightTitle":"Security Consultant","oversightNumber":"703-404-9293 x","oversightEmail":"@synopsys.com","clientManagerName":"","clientManagerTitle":"","clientManagerNumber":"703-404-9293 x","clientManagerEmail":"@synopsys.com","confidentiality":"","integrity":"","availability":"","hash":"671a150524115bebb83a413aff86231f28604a2ea04c930ae3cf27e531b78be4","versionNumber":"2019.03","isTWBAssessment":"false","testID":"","totalInstances":2,"pciReport":false,"retest":false},"findings":[{"identifier":32136,"name":"Security Misconfiguration","description":"Security Misconfiguration can happen at any level of an application stack, including the platform, web server, application server, database, framework, and custom code. Developers and system administrators need to work together to ensure that the entire stack is configured properly.<br>\n","note":"In the application source code, the request validation is explicitly set to false in web.config file.<br>\n","instances":[],"systemic":"false","fixLocation":null,"screenshots":[],"stepsToReproduce":"","likelihoodDescription":"","impactDescription":"","contextDescription":"","remediation":"In the application source code, the request validation feature should not be disabled.<br>\n","foundBy":"Manual","risk":{"type":"NIST","impact":"--select severity--","likelihood":"--select severity--","severity":"--select severity--"},"bnySeverityRiskLevels":["--select severity--","Critical","High","Medium","Low","Informational"],"cvdId":"-1","appscanTitle":"","itrc":"","cweId":"","cweIdFlawName":"","cweIdCategory":"","pciId":"","pciDesc":"","flawCount":0},{"identifier":4135,"name":"Autocomplete HTML Attribute Not Disabled for Sensitive Fields","description":"The HTML autocomplete attribute is not set as disabled for sensitive fields. When autocomplete is enabled for a given HTML form field, the browser attempts to fill in a previously stored value as the user enters information. Unique values entered into these fields are cached by the browser for later use.<br>An attacker can retrieve data cached through the browser's autocomplete mechanism via local access to the browser or remote scripting attack. Any sensitive information stored in the browser's autocomplete cache would be exposed. The consequence of exposure differs depending on the type of data cached. An attacker can use exposed passwords to impersonate victims in the application, or use a victim's PII (such as social security number, account information, etc.) to steal the victim's identity or gain unauthorized access to their accounts.","note":"","instances":[],"systemic":"false","fixLocation":null,"screenshots":[],"stepsToReproduce":"","likelihoodDescription":"","impactDescription":"","contextDescription":"","remediation":"Disable autocomplete for sensitive information, including, but not limited to, passwords and personally identifiable information. To disable autocomplete on an individual input field, set the autocomplete attribute to \"off\":<br>\n<code>&lt;input type=\"text\" name=\"sensitive_input\" value=\"sensitive_value\" autocomplete=\"off\" /&gt;\n</code>\nTo disable autocomplete on an entire form, set the attribute on the form instead of on individual fields:<br>\n<code>&lt;form name=\"sensitive_data_form\" autocomplete=\"off\"&gt;\n</code>","foundBy":"Manual","risk":{"type":"NIST","impact":"Medium","likelihood":"Low","severity":"Low"},"bnySeverityRiskLevels":["--select severity--","Critical","High","Medium","Low","Informational"],"cvdId":"67","appscanTitle":"","itrc":"","cweId":"525","cweIdFlawName":"","cweIdCategory":"","pciId":"N/A","flawCount":0},{"identifier":23967,"name":"Information Leakage via Code Comments","description":"Comments in the application source code contain sensitive information. While code comments are useful for maintenance and readability, sensitive information may be exploited by users authorized to access the code, or leaked to unauthorized individuals who gain access to the code base. Examples of sensitive information commonly found in code comments include (but are not limited to) test credentials, internal email addresses, sample data that illustrates data formats, NPI data such as SSNs and account numbers, IP addresses for internal subsystems, etc. Comments may also give away information about the application's business logic and control flow that would otherwise not be obvious to someone simply reading the code. For example, a comment may point out a bug that is not fixed, or provide information about application logic that could not be discerned by reading the code alone.<br>Sensitive data stored in code is at risk of exposure to various parties, including:<br>\n<ul>\n<li>All developers with access to the source code<br></li>\n<li>Any individual who gains access to the source code by accident (e.g. through lax access control policies set for code repositories)<br></li>\n<li>Any individual who gains access to the source code through malicious action (e.g. through source code disclosure in the running application instance)\nThe consequence of leaking data via code comments depends on the type of information exposed:<br></li>\n<li>Application and other credentials leaked may provide an attacker with unauthorized access to databases and other resources, or allow them to impersonate legitimate application users<br></li>\n<li>Details regarding the internal network's structure, internal IP addresses, and other company-related information may be useful for an attacker performing reconnaissance, to further penetrate the internal network, target employees directly, etc.<br></li>\n<li>Details regarding business logic and application control flow may allow an attacker to more efficiently craft exploits against the running application<br></li>\n</ul>","note":"","instances":[{"url":"URL","instanceParameters":[{"parameter":"Parameter/Header/Cookie"}],"instanceCodeSnippets":[{"codeSnippet":"Code Snippet goes here"}]}],"systemic":"false","fixLocation":null,"screenshots":[],"stepsToReproduce":"","likelihoodDescription":"","impactDescription":"","contextDescription":"","remediation":"Code comments must be worded carefully so that they are useful for application code maintenance, but do not expose any sensitive user or application information. Credentials, IP addresses, PII, internal email addresses, identifiers and other unnecessary information must never be included in code comments.","foundBy":"Manual","risk":{"type":"NIST","impact":"Low","likelihood":"--select severity--","severity":"Low"},"bnySeverityRiskLevels":["--select severity--","Critical","High","Medium","Low","Informational"],"cvdId":"308","appscanTitle":"","itrc":"","cweId":"N/A","cweIdFlawName":"","cweIdCategory":"","pciId":"N/A","flawCount":1},{"identifier":6239,"name":"Cross-Site Request Forgery (CSRF)","description":"A Cross-Site Request Forgery (CSRF) vulnerability occurs when the application fails to ensure that requests received by the server originated from pages served by the application. For example, an attacker creates a malicious website and gets an authenticated user to visit a page on the malicious website. A page from the malicious website sends an HTTP request to the application with data supplied by the attacker. The HTTP request causes the victim's browser to automatically send the user's session cookie along with the request. The application processes the request as though the request had been made from one of the application's pages.<br>A Cross-Site Request Forgery vulnerability allows an attacker to cause a victim's browser to submit requests that successfully perform sensitive operations to the vulnerable application without the application user's knowledge. The attacker controls all of the function parameters and the application executes the function thinking that it is a legitimate request generated by the user.","note":"","instances":[{"url":"URL","instanceParameters":[{"parameter":"Parameter/Header/Cookie"}],"instanceCodeSnippets":[{"codeSnippet":"Code Snippet goes here"}]}],"systemic":"false","fixLocation":null,"screenshots":[],"stepsToReproduce":"","likelihoodDescription":"","impactDescription":"","contextDescription":"","remediation":"Preventing a CSRF vulnerability requires adding a non-predictable parameter to requests that performs any transaction that modifies the application's data or internal state. This parameter must be part of the form and not stored in the cookie. The easiest way to add a non-predictable parameter is to use a secure hash function, such as SHA-2, to hash the user's session ID. This parameter is referred to as a \"form-authenticator\" because this parameter is checked on the server to ensure that this is a legitimate request from the application. The application includes the form-authenticator when a legitimate page is generated (e.g., as a hidden field). When the form is then submitted, the application verifies that the form-authenticator provided from the form matches the one issued when the page was generated. If they match, the request can be processed; otherwise, the application issues an error indicating the request is invalid.","foundBy":"Manual","risk":{"type":"NIST","impact":"High","likelihood":"Medium","severity":"Medium"},"bnySeverityRiskLevels":["--select severity--","Critical","High","Medium","Low","Informational"],"cvdId":"15","appscanTitle":"","itrc":"","cweId":"352","cweIdFlawName":"","cweIdCategory":"","pciId":"6.5.9 ","pciDesc":" Cross-site Request Forgery","flawCount":1}],"customFields":[{"name":"assessmentNotes","label":"Assessment Notes","fieldType":"textarea","value":""}],"riskType":"NIST5","billable":"true","sdr":"false","priorTestingFlag":"false","generatedBy":"tort","totalUploadedFileSize":0}