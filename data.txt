{"practiceType":"--select practice--","associated":[],"metadata":{"clientName":"","clientAddress":"","appName":"","appDescription":"","testType":"Penetration Test - Essential","startDate":"","endDate":"","scope":"","scopeType":"","outOfScope":"","outOfScopeType":"","controlList":"","consultantName":"","consultantTitle":"","consultantNumber":"","consultantEmail":"","oversightName":"","oversightTitle":"","oversightNumber":"","oversightEmail":"","clientManagerName":"","clientManagerTitle":"","clientManagerNumber":"","clientManagerEmail":"","confidentiality":"","integrity":"","availability":"","hash":"29ea2cc3533650d56bf5aab9df2930fcab6e5f40026b4d503bd8381157cfeae0","versionNumber":"2019.03","isTWBAssessment":"false","testID":"","totalInstances":3,"pciReport":false,"retest":false},"findings":[{"identifier":66363,"name":"Cacheable HTTPS Content","description":"Application content served over HTTPS is cached locally on disk. This occurs as a result of missing HTML cache control tags and missing or misconfigured cache control headers in HTTP responses from the server.<br>An attacker with local access to a user's web browser may be able to retrieve cached copies of resources that the user previously accessed, exposing any stored sensitive data.","note":"","instances":[{"url":"URL","instanceParameters":[{"parameter":"Parameter/Header/Cookie"}],"instanceCodeSnippets":[]}],"systemic":"false","fixLocation":null,"screenshots":[],"stepsToReproduce":"","likelihoodDescription":"","impactDescription":"","contextDescription":"","remediation":"The web server should be configured to set cache behavior on all pages. To prevent a page from being cached, the Cache-Control directive must be set to no-store. This is the most secure of the cache-control directives. It instructs the browser not to cache the page and not store the page in its cache folder. This directive should be used for all sensitive pages. With this set, the application will have the greatest control possible over how its pages will be cached. Other directives, such as Pragma: no-cache and Expires HTTP headers should be set as well (Note: these headers do not guarantee that a browser will not store the data in its cache folder, but are honored in certain browsers).<br>\nNote: The (misleadingly named) \"no-cache\" directive instructs the browser to revalidate with the server before serving the page from the cache. The browser may still store the page in its cache. In addition, some modern browsers have been modified to implement the \"no-cache\" directive like the \"no-store\" directive. To be on the safer side, developers can use both \"no-cache\" and \"no-store\" when serving sensitive pages.","foundBy":"Manual","risk":{"type":"NIST","impact":"--select severity--","likelihood":"--select severity--","severity":"--select severity--"},"bnySeverityRiskLevels":["--select severity--","Critical","High","Medium","Low","Informational"],"cvdId":"21","appscanTitle":"","itrc":"","cweId":"525","cweIdFlawName":"","cweIdCategory":"","pciId":"N/A","flawCount":1},{"identifier":48353,"name":"Cross-Site Request Forgery (CSRF)","description":"A Cross-Site Request Forgery (CSRF) vulnerability occurs when the application fails to ensure that requests received by the server originated from pages served by the application. For example, an attacker creates a malicious website and gets an authenticated user to visit a page on the malicious website. A page from the malicious website sends an HTTP request to the application with data supplied by the attacker. The HTTP request causes the victim's browser to automatically send the user's session cookie along with the request. The application processes the request as though the request had been made from one of the application's pages.<br>A Cross-Site Request Forgery vulnerability allows an attacker to cause a victim's browser to submit requests that successfully perform sensitive operations to the vulnerable application without the application user's knowledge. The attacker controls all of the function parameters and the application executes the function thinking that it is a legitimate request generated by the user.","note":"","instances":[{"url":"URL","instanceParameters":[{"parameter":"Parameter/Header/Cookie"}],"instanceCodeSnippets":[]}],"systemic":"false","fixLocation":null,"screenshots":[],"stepsToReproduce":"","likelihoodDescription":"","impactDescription":"","contextDescription":"","remediation":"Preventing a CSRF vulnerability requires adding a non-predictable parameter to requests that performs any transaction that modifies the application's data or internal state. This parameter must be part of the form and not stored in the cookie. The easiest way to add a non-predictable parameter is to use a secure hash function, such as SHA-2, to hash the user's session ID. This parameter is referred to as a \"form-authenticator\" because this parameter is checked on the server to ensure that this is a legitimate request from the application. The application includes the form-authenticator when a legitimate page is generated (e.g., as a hidden field). When the form is then submitted, the application verifies that the form-authenticator provided from the form matches the one issued when the page was generated. If they match, the request can be processed; otherwise, the application issues an error indicating the request is invalid.","foundBy":"Manual","risk":{"type":"NIST","impact":"--select severity--","likelihood":"--select severity--","severity":"--select severity--"},"bnySeverityRiskLevels":["--select severity--","Critical","High","Medium","Low","Informational"],"cvdId":"15","appscanTitle":"","itrc":"","cweId":"352","cweIdFlawName":"","cweIdCategory":"","pciId":"6.5.9 ","pciDesc":" Cross-site Request Forgery","flawCount":1},{"identifier":45552,"name":"Autocomplete HTML Attribute Not Disabled for Sensitive Fields","description":"The HTML autocomplete attribute is not set as disabled for sensitive fields. When autocomplete is enabled for a given HTML form field, the browser attempts to fill in a previously stored value as the user enters information. Unique values entered into these fields are cached by the browser for later use.<br>An attacker can retrieve data cached through the browser's autocomplete mechanism via local access to the browser or remote scripting attack. Any sensitive information stored in the browser's autocomplete cache would be exposed. The consequence of exposure differs depending on the type of data cached. An attacker can use exposed passwords to impersonate victims in the application, or use a victim's PII (such as social security number, account information, etc.) to steal the victim's identity or gain unauthorized access to their accounts.","note":"","instances":[{"url":"URL","instanceParameters":[{"parameter":"Parameter/Header/Cookie"}],"instanceCodeSnippets":[]}],"systemic":"false","fixLocation":null,"screenshots":[],"stepsToReproduce":"","likelihoodDescription":"","impactDescription":"","contextDescription":"","remediation":"Disable autocomplete for sensitive information, including, but not limited to, passwords and personally identifiable information. To disable autocomplete on an individual input field, set the autocomplete attribute to \"off\":<br>\n<code>&lt;input type=\"text\" name=\"sensitive_input\" value=\"sensitive_value\" autocomplete=\"off\" /&gt;\n</code>\nTo disable autocomplete on an entire form, set the attribute on the form instead of on individual fields:<br>\n<code>&lt;form name=\"sensitive_data_form\" autocomplete=\"off\"&gt;\n</code>","foundBy":"Manual","risk":{"type":"NIST","impact":"--select severity--","likelihood":"--select severity--","severity":"--select severity--"},"bnySeverityRiskLevels":["--select severity--","Critical","High","Medium","Low","Informational"],"cvdId":"67","appscanTitle":"","itrc":"","cweId":"525","cweIdFlawName":"","cweIdCategory":"","pciId":"N/A","flawCount":1}],"customFields":[],"riskType":"NIST","billable":"true","sdr":"false","priorTestingFlag":"false","generatedBy":"tort","totalUploadedFileSize":0}