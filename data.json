{"practiceType":"Secure Development","selectedClient":"Standard","associated":[],"metadata":{"clientName":"Standard","clientAddress":"","appName":"","appDescription":"","testType":"Penetration Test - Essential","startDate":"","endDate":"","scope":"","scopeType":"","outOfScope":"","outOfScopeType":"","controlList":"","consultantName":"","consultantTitle":"","consultantNumber":"","consultantEmail":"","oversightName":"","oversightTitle":"Security Consultant","oversightNumber":"703-404-9293 x","oversightEmail":"@synopsys.com","clientManagerName":"","clientManagerTitle":"","clientManagerNumber":"703-404-9293 x","clientManagerEmail":"@synopsys.com","confidentiality":"","integrity":"","availability":"","hash":"671a150524115bebb83a413aff86231f28604a2ea04c930ae3cf27e531b78be4","versionNumber":"2019.03","isTWBAssessment":"false","testID":"","totalInstances":0,"pciReport":false,"retest":false},"findings":[{"identifier":5869,"name":"Unsalted Password Hashes","description":"User passwords are stored as unsalted hashes within the application's backend database. While storing passwords as hashes obscures them in the event that the database is compromised, all hashing algorithms are vulnerable to \"rainbow table\" attacks. A rainbow table is a pre-generated dictionary of hashes and their associated plain-text values. With a rainbow table available, an attacker with a hash needs only to look up that hash in the table to obtain a user's plain-text password. As rainbow tables are readily available, looking up the plain-text value of an unsalted hash would take very little time and effort.<br>\nIf an attacker gains access to the user database, user credentials will be directly exposed, allowing the attacker to impersonate legitimate users. The attacker could obtain sensitive information, modify or insert new data, as well as perform any other actions available to legitimate users. The impact of such unauthorized access to data and functionality cannot be overstated and may include data loss, large scale failure or inaccuracies in data. This will in turn affect the business goals of availability, integrity, and confidentiality.<br>\n\nAn attacker may be able to gain access to the application database in several ways. If an attacker discovers a SQL injection flaw in the application that allows them even read-only access, every user's credentials may be exposed. If the application is free of vulnerabilities that expose database information to the attacker through the web application, a potential threat still exists when an insider with access to the database retrieves other users' credentials. For example, the database administrator (who may very well not have any legitimate business reason for accessing a particular application's functionality) could simply read credentials from the database and access the application as a valid application user. An outsider may also be able to obtain access to backup tapes or discarded hard discs containing database information which would in turn expose clear-text user credentials.<br>\n","note":"","instances":[],"systemic":"false","fixLocation":null,"screenshots":[],"stepsToReproduce":"","likelihoodDescription":"","impactDescription":"","contextDescription":"User passwords are stored as unsalted hashes in the application's backend database.<br>\n","remediation":"For defense-in-depth, passwords should be salted and hashed to prevent an attacker from gaining access to clear-text passwords in the event that the database table containing user passwords is compromised. The first step toward securely storing passwords involves generating a secure random, fixed-length, at least 32 bits, token (or \"salt\") when the clear-text password is about to be stored in the database.<br>\n\n<code>SALT = rand(32bits)\n</code>\nAdditionally, consider larger salt (32 or 64 bytes) for large user base to avoid salt collisions. The salt value and clear-text password should then be supplied as inputs to a cryptographically secure one-way key derivation function. A key derivation function derives one or more secret keys from a secret value such as a master key or other known information such as a password or passphrase using a pseudo-random function. Some examples include PBKDF#2, BALLOON, bcrypt and scrypt. The key derivation function must use an approved one-way function such as Keyed Hash Message Authentication Code (HMAC), any approved hash function in NIST SP 800-107, SHA-3, CMAC, KMAC, or cSHAKE.<br>\n\n<code>OUT = PBKDF2WithHmacSHA3-512(KEY, PW, SALT, WORK FACTOR) + \":\" + SALT;\n</code>\nImproved security from MAC is contingent upon the proper key management of the MAC key. MAC key must be protected as any other private key using established key management practices including secure key generation and storage. Besides, multiple key versions need to be supported when rotating keys to account for the password hash change using new key.<br>\n\nAdditionally, developers must specify a \"work factor\" for the function. This parameter's value will change depending on the chosen function but should be tuned to execute in 1/100th of a second (lower/higher depending on peak user load requirements) in the production environment. The work factor should also be tweaked every 1-2 years as computers get faster. Once the password is salted and hashed, the hash and plaintext salt can be stored in the database alongside the username.<br>\n\nNote: once passwords are salted and hashed in the database, any functionality which involves user credentials will need to be modified to account for the change in how passwords are stored. When a user logs in, the application will need to take the supplied clear-text password and associated salt, then compute the hash using key derivation function and compare the resulting hash with the hash stored for that user. If the hashes match, the supplied password matches the one the user submitted initially.<br>\n\nFor more information, Refer:\nhttps://www.owasp.org/index.php/Password<em>Storage</em>Cheat_Sheet\nhttps://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63b.pdf\nhttps://nvlpubs.nist.gov/nistpubs/legacy/sp/nistspecialpublication800-107r1.pdf<br>\n","foundBy":"Manual","risk":{"type":"NIST","impact":"Medium","likelihood":"Medium","severity":"Medium"},"bnySeverityRiskLevels":["--select severity--","Critical","High","Medium","Low","Informational"],"cvdId":"17","appscanTitle":"","itrc":"","cweId":"759","cweIdFlawName":"","cweIdCategory":"","pciId":"6.5.3 ","pciDesc":" Insecure Cryptographic Storage","flawCount":0},{"identifier":48199,"name":"Weak Hash Function","description":"The application uses a weak cryptographic hashing function. A weak cryptographic hashing function is one that does not meet the following requirements:<br>\n<ul>\n<li>Pre-image resistance: it is infeasible to generate a message that has a given hash</li>\n<li>Collision resistance: it is infeasible to find two different messages with the same hash</li>\n<li>Second pre-image resistance: it is infeasible to modify a message without change the hash\nWeak cryptographic hashing functions may allow plaintext data to be retrieved from hash values in multiple ways, depending on the specific weakness in the hash function itself. For example, algorithms such as MD5 have been proven to contain known collisions, violating the need for collision resistance and second pre-image resistance.</li>\n</ul>\nAlternately, the application may be using a non-cryptographic hashing function in place of a cryptographic hashing function. An example of this would be the use of Cyclic Redundancy Checks (CRC).<br>Use of weak hashing functions may provide an attacker with the ability to recover the plaintext that was used to create the hash. The plaintext may contain sensitive data such as passwords or personally identifiable information. Additionally, weak hashing functions vulnerable to collision attacks can be abused to generate an identical hash expected by the server/application without knowledge of the original plaintext. A collision attack could aid an attacker in:<br>\n<ul>\n<li>Bypassing a digital signing mechanism used by the server/application.</li>\n<li>Bypassing authentication without knowledge of the original password.</li>\n</ul>","note":"","instances":[],"systemic":"false","fixLocation":null,"screenshots":[],"stepsToReproduce":"","likelihoodDescription":"","impactDescription":"","contextDescription":"","remediation":"Ensure the use of cryptographically strong hashing algorithms such the ones approved by NIST:<br>\nhttp://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html","foundBy":"Manual","risk":{"type":"NIST","impact":"Medium","likelihood":"Medium","severity":"Medium"},"bnySeverityRiskLevels":["--select severity--","Critical","High","Medium","Low","Informational"],"cvdId":"76","appscanTitle":"","itrc":"","cweId":"310","cweIdFlawName":"","cweIdCategory":"","pciId":"6.5.4 ","pciDesc":" Insecure Communication","flawCount":0}],"customFields":[{"name":"assessmentNotes","label":"Assessment Notes","fieldType":"textarea","value":""}],"riskType":"NIST5","billable":"true","sdr":"false","priorTestingFlag":"false","generatedBy":"tort","totalUploadedFileSize":0}